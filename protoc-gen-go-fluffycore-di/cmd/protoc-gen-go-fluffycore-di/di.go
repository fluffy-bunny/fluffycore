package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	sync_package               = protogen.GoImportPath("sync")
	context_package            = protogen.GoImportPath("context")
	errors_package             = protogen.GoImportPath("errors")
	grpc_package               = protogen.GoImportPath("google.golang.org/grpc")
	grpcGatewayRuntimePackage  = protogen.GoImportPath("github.com/grpc-ecosystem/grpc-gateway/v2/runtime")
	grpc_status_package        = protogen.GoImportPath("google.golang.org/grpc/status")
	grpc_codes_package         = protogen.GoImportPath("google.golang.org/grpc/codes")
	di_Package                 = protogen.GoImportPath("github.com/fluffy-bunny/fluffy-dozm-di")
	reflectx_package           = protogen.GoImportPath("github.com/fluffy-bunny/fluffy-dozm-di/reflectx")
	dicontext_package          = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/middleware/dicontext")
	contracts_dndpoint_package = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/contracts/endpoint")
	// 	fluffycore_contracts_tokensource "github.com/fluffy-bunny/fluffycore/contracts/tokensource"
	contracts_tokensource_package = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/contracts/tokensource")
	// 	fluffycore_contracts_GRPCClientFactory "github.com/fluffy-bunny/fluffycore/contracts/GRPCClientFactory"
	contracts_GRPCClientFactory_package = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/contracts/GRPCClientFactory")
	// 	fluffycore_grpcclient "github.com/fluffy-bunny/fluffycore/grpcclient"
	grpcclient_package = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/grpcclient")
)

type genFileContext struct {
	packageName string
	uniqueRunID string
	gen         *protogen.Plugin
	file        *protogen.File
	filename    string
	g           *protogen.GeneratedFile
}

func newMethodGenContext(uniqueRunId string, protogenMethod *protogen.Method, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *methodGenContext {
	ctx := &methodGenContext{
		uniqueRunID:    uniqueRunId,
		MethodInfo:     &MethodInfo{},
		ProtogenMethod: protogenMethod,
		gen:            gen,
		file:           file,
		g:              g,
		service:        service,
	}
	return ctx
}
func newGenFileContext(gen *protogen.Plugin, file *protogen.File) *genFileContext {
	ctx := &genFileContext{
		file:        file,
		gen:         gen,
		uniqueRunID: randomString(32),
		packageName: string(file.GoPackageName),
		filename:    file.GeneratedFilenamePrefix + "_fluffycore_di.pb.go",
	}
	ctx.g = gen.NewGeneratedFile(ctx.filename, file.GoImportPath)
	return ctx
}
func isServiceIgnored(service *protogen.Service) bool {
	// Look for a comment consisting of "fluffycore:di:ignore"
	const ignore = "fluffycore:di:ignore"
	for _, comment := range service.Comments.LeadingDetached {
		if strings.Contains(string(comment), ignore) {
			return true
		}
	}

	return strings.Contains(string(service.Comments.Leading), ignore)
}

// generateFile generates a _di.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	ctx := newGenFileContext(gen, file)
	g := ctx.g

	// Default to skip - will unskip if there is a service to generate
	g.Skip()

	g.P("// Code generated by protoc-gen-go-fluffycore-di. DO NOT EDIT.")
	if *grpcGatewayEnabled {
		g.P("// Code generated grpcGateway")
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	ctx.generateFileContent()
	return g
}

type MethodInfo struct {
	NewResponseWithErrorFunc string
	NewResponseFunc          string
	ExecuteFunc              string
}
type methodGenContext struct {
	MethodInfo     *MethodInfo
	ProtogenMethod *protogen.Method
	gen            *protogen.Plugin
	file           *protogen.File
	g              *protogen.GeneratedFile
	service        *protogen.Service
	uniqueRunID    string
}
type serviceGenContext struct {
	packageName     string
	MethodMapGenCtx map[string]*methodGenContext
	gen             *protogen.Plugin
	file            *protogen.File
	g               *protogen.GeneratedFile
	service         *protogen.Service
	uniqueRunID     string
}

func newServiceGenContext(packageName string, uniqueRunId string, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *serviceGenContext {
	ctx := &serviceGenContext{
		packageName:     packageName,
		uniqueRunID:     uniqueRunId,
		gen:             gen,
		file:            file,
		g:               g,
		service:         service,
		MethodMapGenCtx: make(map[string]*methodGenContext),
	}
	return ctx
}

// generateFileContent generates the DI service definitions, excluding the package statement.
func (s *genFileContext) generateFileContent() {
	gen := s.gen
	file := s.file
	g := s.g

	//var serviceGenCtxs []*serviceGenContext
	// Generate each service
	for _, service := range file.Services {
		// Check if this service is ignored for DI purposes
		if isServiceIgnored(service) {
			continue
		}

		// Now we have something to generate
		g.Unskip()

		serviceGenCtx := newServiceGenContext(s.packageName, s.uniqueRunID, gen, file, g, service)
		serviceGenCtx.genService()
		//serviceGenCtxs = append(serviceGenCtxs, serviceGenCtx)
	}
}
func (s *serviceGenContext) genService() {
	gen := s.gen
	file := s.file
	proto := file.Proto
	g := s.g
	service := s.service

	// IServiceEndpointRegistration
	interfaceGRPCServerName := fmt.Sprintf("%vServer", service.GoName)
	interfaceGRPCClientName := fmt.Sprintf("%vClient", service.GoName)

	interfaceServerName := fmt.Sprintf("IFluffyCore%s", interfaceGRPCServerName)
	interfaceClientAccessorName := fmt.Sprintf("IApp%sAccessor", interfaceGRPCClientName)
	internalServerName := fmt.Sprintf("%vFluffyCoreServer", service.GoName)
	internalClientAccessorStructName := fmt.Sprintf("App%vAccessor", interfaceGRPCClientName)
	internalClientAccessorConfigStructName := fmt.Sprintf("App%vAccessorConfig", interfaceGRPCClientName)

	g.P("// ", interfaceClientAccessorName, " defines the grpc client")
	g.P("type ", interfaceClientAccessorName, " interface {")
	g.P("  	", "GetClient() (", interfaceGRPCClientName, ", error)")
	g.P("}")
	g.P()

	g.P("// ", internalClientAccessorConfigStructName, " defines the grpc client struct")
	g.P("type ", internalClientAccessorConfigStructName, " struct {")
	g.P("    Url string ")
	g.P("}")
	g.P()

	g.P("// ", internalClientAccessorStructName, " defines the grpc client struct")
	g.P("type ", internalClientAccessorStructName, " struct {")
	g.P("    rwLock ", sync_package.Ident("RWMutex"))
	g.P("    config *", internalClientAccessorConfigStructName)
	g.P("    appTokenSource ", contracts_tokensource_package.Ident("IAppTokenSource"))
	g.P("    grpcClientFactory ", contracts_GRPCClientFactory_package.Ident("IGRPCClientFactory"))
	g.P("    client ", interfaceGRPCClientName)
	g.P("}")
	g.P()

	// var stemService = (*service)(nil)
	g.P("var stem", internalClientAccessorStructName, " = (*", internalClientAccessorStructName, ")(nil)")
	// var _ fluffycore_contracts_jwtminter.IKeyMaterial = stemService
	g.P("var _ ", interfaceClientAccessorName, " = stem", internalClientAccessorStructName)
	g.P()
	// contracts_tokensource_package
	g.P("func (s *", internalClientAccessorStructName, ") Ctor (\n    ",
		"config *", internalClientAccessorConfigStructName, ",\n    ",
		"appTokenSource ", contracts_tokensource_package.Ident("IAppTokenSource"), ",\n    ",
		"grpcClientFactory ", contracts_GRPCClientFactory_package.Ident("IGRPCClientFactory"), ",\n    ",
		") (", interfaceClientAccessorName, " ,error) {")
	g.P("   return &", internalClientAccessorStructName, "{")
	g.P("       config: config,")
	g.P("       appTokenSource: appTokenSource,")
	g.P("       grpcClientFactory: grpcClientFactory,")
	g.P("   }, nil")
	g.P("}")
	g.P()
	/*
	   	func AddSingletonIMappedGRPCClientFactory(cb di.ContainerBuilder) {
	   	di.AddSingleton[commoncore_contracts_grpcclientfactory.IMappedGRPCClientFactory](cb, stemService.CtorDozm)
	   	di.AddSingleton[commoncore_contracts_grpcclientfactory.IMappedNATSClientFactory](cb, stemService.CtorDozmNATS)
	   }
	*/
	g.P("// AddSingleton", interfaceClientAccessorName, " ...")
	g.P("func AddSingleton", interfaceClientAccessorName, "(\n    ",
		"cb ", di_Package.Ident("ContainerBuilder"), ",\n    ",
		"config *", internalClientAccessorConfigStructName, ",\n    ",
		") {")
	g.P("   ", di_Package.Ident("AddInstance"), "[*", internalClientAccessorConfigStructName, "](cb,config)")
	g.P("   ", di_Package.Ident("AddSingleton"), "[", interfaceClientAccessorName, "](cb,stem", internalClientAccessorStructName, ".Ctor)")
	g.P("}")
	g.P()

	/*
			func (s *service) GetOrgServiceClient() (cloud_api_orgs.OrgServiceClient, error) {

			doGetClient := func() cloud_api_orgs.OrgServiceClient {
				s.rwLock.RLock()
				defer s.rwLock.RUnlock()
				if s.orgServiceClient != nil {
					return s.orgServiceClient
				}
				return nil
			}

			client := doGetClient()
			if client != nil {
				return client, nil
			}

			tokenSource := s.getTokenSource(context.Background())
			//--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--
			s.rwLock.Lock()
			defer s.rwLock.Unlock()
			//--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--

			serviceClient, err := grpcclient.NewGrpcClient(
				grpcclient.WithTarget(s.config.OrgsServiceURI),
				grpcclient.WithTokenSource(tokenSource),
				grpcclient.WithInsecure(true), // TODO: remove this in production
			)
			if err != nil {
				return nil, err
			}
			s.orgServiceClient = cloud_api_orgs.NewOrgServiceClient(serviceClient.GetConnection())
			return s.orgServiceClient, nil
		}

	*/
	g.P("func (s *", internalClientAccessorStructName, ") GetClient () (", interfaceGRPCClientName, ", error) {")
	g.P("   doGetClient := func() ", interfaceGRPCClientName, " {")
	g.P("       s.rwLock.RLock()")
	g.P("       defer s.rwLock.RUnlock()")
	g.P("       if s.client != nil {")
	g.P("           return s.client")
	g.P("       }")
	g.P("       return nil")
	g.P("   }")
	g.P()
	g.P("   client := doGetClient()")
	g.P("   if client != nil {")
	g.P("       return client,nil")
	g.P("   }")
	g.P()
	g.P("   tokenSource,err := s.appTokenSource.GetTokenSource()")
	g.P("   if err != nil {")
	g.P("       return nil, err")
	g.P("   }")
	g.P("   //--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--")
	g.P("   s.rwLock.Lock()")
	g.P("   defer s.rwLock.Unlock()")
	g.P("   //--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--~--")
	g.P()
	g.P("   // Re-check after acquiring write lock (double-checked locking)")
	g.P("   if s.client != nil {")
	g.P("       return s.client, nil")
	g.P("   }")
	g.P()
	g.P("   grpcClient, err := s.grpcClientFactory.NewGrpcClient(")
	g.P("       ", grpcclient_package.Ident("WithTarget"), "(s.config.Url),")
	g.P("       ", grpcclient_package.Ident("WithTokenSource"), "(tokenSource),")
	g.P("       ", grpcclient_package.Ident("WithInsecure"), "(true), // TODO: remove this in production")
	g.P("   )")
	g.P("   if err != nil {")
	g.P("       return nil, err")
	g.P("   }")
	g.P("   s.client =  New", interfaceGRPCClientName, "(grpcClient.GetConnection())")
	g.P("   return s.client, nil")
	g.P("}")
	g.P()

	g.P("// ", interfaceServerName, " defines the grpc server")
	g.P("type ", interfaceServerName, " interface {")
	g.P("  	", service.GoName, "Server")
	g.P("}")
	g.P()

	g.P("type UnimplementedFluffyCore", service.GoName, "ServerEndpointRegistration struct {")
	g.P("}")
	g.P()

	g.P("func (UnimplementedFluffyCore", service.GoName, "ServerEndpointRegistration) RegisterFluffyCoreHandler(gwmux *", grpcGatewayRuntimePackage.Ident("ServeMux"),
		",conn *", grpc_package.Ident("ClientConn"), ") {")
	g.P("}")
	g.P()

	// Define the ServiceEndpointRegistration implementation
	//----------------------------------------------------------------------------------------------
	g.P("// ", internalServerName, " defines the grpc server truct")
	g.P("type ", internalServerName, " struct {")
	g.P("  	", "Unimplemented", service.GoName, "Server")
	g.P("  	", "UnimplementedFluffyCore", service.GoName, "ServerEndpointRegistration")
	g.P("}")
	g.P()

	g.P("// RegisterFluffyCoreGRPCService the server with grpc")
	g.P("func (srv *", internalServerName, ") RegisterFluffyCoreGRPCService(s *", grpc_package.Ident("Server"), ") {")
	g.P("   ", "Register", interfaceGRPCServerName, "(s,srv)")
	g.P("}")

	g.P("// Add", service.GoName, "ServerWithExternalRegistration", " adds the fluffycore aware grpc server and external registration service.  Mainly used for grpc-gateway")
	g.P("func Add", service.GoName, "ServerWithExternalRegistration(cb ", di_Package.Ident("ContainerBuilder"), ", ctor any, register func() ", contracts_dndpoint_package.Ident("IEndpointRegistration"), " ) {")
	g.P("   ", di_Package.Ident("AddSingleton"), "[", contracts_dndpoint_package.Ident("IEndpointRegistration"), "](cb,register)")
	g.P("   ", di_Package.Ident("AddScoped"), "[", interfaceServerName, "](cb,ctor)")
	g.P("}")

	g.P("// Add", service.GoName, "Server", " adds the fluffycore aware grpc server")
	g.P("func Add", service.GoName, "Server(cb ", di_Package.Ident("ContainerBuilder"), ", ctor any) {")
	g.P("   Add", service.GoName, "ServerWithExternalRegistration(cb,ctor,func() ", contracts_dndpoint_package.Ident("IEndpointRegistration"), " {")
	g.P("      return &", internalServerName, "{}")
	g.P("   })")
	g.P("}")

	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := newMethodGenContext(s.uniqueRunID, method, gen, file, g, service)
		s.MethodMapGenCtx[key] = methodGenCtx
	}
	// Client method implementations.
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		methodGenCtx.genServerMethodShim()
	}
}
func (s *methodGenContext) genServerMethodShim() {

	method := s.ProtogenMethod

	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		s.generateUnaryServerMethodShim()
	} else {
		s.generateStreamServerMethodShim()
	}

}
func (s *methodGenContext) generateUnaryServerMethodShim() {

	method := s.ProtogenMethod
	g := s.g
	serverType := method.Parent.GoName
	interfaceServerName := fmt.Sprintf("IFluffyCore%vServer", method.Parent.GoName)
	internalServerName := fmt.Sprintf("%vFluffyCoreServer", serverType)

	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", internalServerName, ") ", s.unaryMethodSignature(), "{")
	g.P("requestContainer := ", dicontext_package.Ident("GetRequestContainer(ctx)"))
	g.P("downstreamService := ", di_Package.Ident("Get"), "[", interfaceServerName, "](requestContainer)")
	g.P("return downstreamService.", method.GoName, "(ctx,request)")
	g.P("}")
	g.P()
}
func (s *methodGenContext) generateStreamServerMethodShim() {
	method := s.ProtogenMethod
	g := s.g
	serverType := method.Parent.GoName
	interfaceServerName := fmt.Sprintf("IFluffyCore%vServer", method.Parent.GoName)
	internalServerName := fmt.Sprintf("%vFluffyCoreServer", serverType)

	sig, argCount := s.streamMethodSignature()

	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", internalServerName, ") ", sig, "{")
	g.P("ctx := stream.Context()")
	g.P("requestContainer := ", dicontext_package.Ident("GetRequestContainer(ctx)"))
	g.P("downstreamService := ", di_Package.Ident("Get"), "[", interfaceServerName, "](requestContainer)")
	if argCount == 1 {
		// stream only
		g.P("return downstreamService.", method.GoName, "(stream)")
	} else {
		// stream and context
		g.P("return downstreamService.", method.GoName, "(request,stream)")
	}
	g.P("}")
	g.P()

}

func (s *methodGenContext) unaryMethodSignature() string {
	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+g.QualifiedGoIdent(context_package.Ident("Context")))
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}

	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
func (s *methodGenContext) streamMethodSignature() (string, int) {
	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := "error"

	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "stream "+method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret, len(reqArgs)
}
