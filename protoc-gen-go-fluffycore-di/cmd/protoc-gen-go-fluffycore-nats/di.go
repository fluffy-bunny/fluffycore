package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage                   = protogen.GoImportPath("context")
	reflectPackage                   = protogen.GoImportPath("reflect")
	fmtPackage                       = protogen.GoImportPath("fmt")
	stringsPackage                   = protogen.GoImportPath("strings")
	errorsPackage                    = protogen.GoImportPath("errors")
	timePackage                      = protogen.GoImportPath("time")
	grpcPackage                      = protogen.GoImportPath("google.golang.org/grpc")
	grpcGatewayRuntimePackage        = protogen.GoImportPath("github.com/grpc-ecosystem/grpc-gateway/v2/runtime")
	grpcStatusPackage                = protogen.GoImportPath("google.golang.org/grpc/status")
	grpcCodesPackage                 = protogen.GoImportPath("google.golang.org/grpc/codes")
	diPackage                        = protogen.GoImportPath("github.com/fluffy-bunny/fluffy-dozm-di")
	reflectxPackage                  = protogen.GoImportPath("github.com/fluffy-bunny/fluffy-dozm-di/reflectx")
	diContextPackage                 = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/middleware/dicontext")
	contractsEndpointPackage         = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/contracts/endpoint")
	natsGoPackage                    = protogen.GoImportPath("github.com/nats-io/nats.go")
	natsGoMicroPackage               = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
	contractsNatsMicroServicePackage = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/contracts/nats_micro_service")
	fluffyCoreUtilsPackage           = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/utils")
	serviceNatsMicroServicePackage   = protogen.GoImportPath("github.com/fluffy-bunny/fluffycore/nats/nats_micro_service")
	protojsonPackage                 = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
)

type genFileContext struct {
	packageName string
	uniqueRunID string
	gen         *protogen.Plugin
	file        *protogen.File
	filename    string
	g           *protogen.GeneratedFile
}

func newMethodGenContext(uniqueRunId string, protogenMethod *protogen.Method, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *methodGenContext {
	ctx := &methodGenContext{
		uniqueRunID:    uniqueRunId,
		MethodInfo:     &MethodInfo{},
		ProtogenMethod: protogenMethod,
		gen:            gen,
		file:           file,
		g:              g,
		service:        service,
	}
	return ctx
}
func newGenFileContext(gen *protogen.Plugin, file *protogen.File) *genFileContext {
	ctx := &genFileContext{
		file:        file,
		gen:         gen,
		uniqueRunID: randomString(32),
		packageName: string(file.GoPackageName),
		filename:    file.GeneratedFilenamePrefix + "_fluffycore_nats.pb.go",
	}
	ctx.g = gen.NewGeneratedFile(ctx.filename, file.GoImportPath)
	return ctx
}
func isServiceIgnored(service *protogen.Service) bool {
	// Look for a comment consisting of "fluffycore:nats:ignore"
	const ignore = "fluffycore:nats:ignore"
	for _, comment := range service.Comments.LeadingDetached {
		if strings.Contains(string(comment), ignore) {
			return true
		}
	}

	return strings.Contains(string(service.Comments.Leading), ignore)
}

// generateFile generates a _di.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	ctx := newGenFileContext(gen, file)
	g := ctx.g

	// Default to skip - will unskip if there is a service to generate
	g.Skip()

	g.P("// Code generated by protoc-gen-go-fluffycore-nats. DO NOT EDIT.")

	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	ctx.generateFileContent()
	return g
}

type MethodInfo struct {
	NewResponseWithErrorFunc string
	NewResponseFunc          string
	ExecuteFunc              string
}
type methodGenContext struct {
	MethodInfo     *MethodInfo
	ProtogenMethod *protogen.Method
	gen            *protogen.Plugin
	file           *protogen.File
	g              *protogen.GeneratedFile
	service        *protogen.Service
	uniqueRunID    string
}
type serviceGenContext struct {
	packageName     string
	MethodMapGenCtx map[string]*methodGenContext
	gen             *protogen.Plugin
	file            *protogen.File
	g               *protogen.GeneratedFile
	service         *protogen.Service
	uniqueRunID     string
}

func newServiceGenContext(packageName string, uniqueRunId string, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *serviceGenContext {
	ctx := &serviceGenContext{
		packageName:     packageName,
		uniqueRunID:     uniqueRunId,
		gen:             gen,
		file:            file,
		g:               g,
		service:         service,
		MethodMapGenCtx: make(map[string]*methodGenContext),
	}
	return ctx
}

// generateFileContent generates the DI service definitions, excluding the package statement.
func (s *genFileContext) generateFileContent() {
	gen := s.gen
	file := s.file
	g := s.g

	//var serviceGenCtxs []*serviceGenContext
	// Generate each service
	for _, service := range file.Services {
		// Check if this service is ignored for DI purposes
		if isServiceIgnored(service) {
			continue
		}

		// Now we have something to generate
		g.Unskip()

		serviceGenCtx := newServiceGenContext(s.packageName, s.uniqueRunID, gen, file, g, service)
		serviceGenCtx.genService()
		serviceGenCtx.genClient()
		//serviceGenCtxs = append(serviceGenCtxs, serviceGenCtx)
	}
}
func (s *serviceGenContext) genClient() {
	//	gen := s.gen
	//file := s.file
	//	proto := file.Proto
	g := s.g
	service := s.service

	atLeastOneMethod := false
	for _, method := range service.Methods {
		// only do it if it is not streaming
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			atLeastOneMethod = true
			break
		}
	}
	if !atLeastOneMethod {
		return
	}
	interfaceGRPCServerName := fmt.Sprintf("%vServerNATSMicro", service.GoName)
	interfaceServerName := fmt.Sprintf("IFluffyCore%s", interfaceGRPCServerName)
	internalClientName := fmt.Sprintf("%vNATSMicroClient", service.GoName)

	/*
			type (
			serviceNATSClientServiceClient struct {
				nc *nats.Conn
			}
		)
	*/
	g.P("type (")
	g.P("	", internalClientName, " struct {")
	g.P("		nc *", natsGoPackage.Ident("Conn"))
	g.P("		groupName string")
	g.P("	}")
	g.P(")")

	/*
			func NewClient(nc *nats.Conn) (cloud_api_business_nats.NATSClientServiceClient, error) {
			return &serviceNATSClientServiceClient{
				nc: nc,
			}, nil
		}
	*/
	g.P("func New", internalClientName, "(nc *", natsGoPackage.Ident("Conn"), ") (", s.service.GoName, "Client, error) {")
	g.P("  	pkgPath := ", reflectPackage.Ident("TypeOf"), "((*", interfaceServerName, ")(nil)).Elem().PkgPath()")
	g.P("  	fullPath := ", fmtPackage.Ident("Sprintf"), "(\"%s/%s\", pkgPath, \"", service.GoName, "\")")
	g.P("  	groupName := ", stringsPackage.Ident("ReplaceAll"), "(")
	g.P("  		fullPath,")
	g.P("  		\"/\",")
	g.P("  		\".\",")
	g.P("  	)")
	g.P("	return &", internalClientName, "{")
	g.P("		nc: nc,")
	g.P("		groupName: groupName,")

	g.P("	}, nil")
	g.P("}")

	/*
			func (s *serviceNATSClientServiceClient) CreateNATSClient(ctx context.Context, in *cloud_api_business_nats.CreateNATSClientRequest, opts ...grpc.CallOption) (*cloud_api_business_nats.CreateNATSClientResponse, error) {

			response := &cloud_api_business_nats.CreateNATSClientResponse{}

			result, err := HandleNATSRequest(
				ctx,
				s.nc,
				"go.mapped.dev.proto.cloud.api.business.nats.NATSClientService.CreateNATSClient",
				in,
				response,
				2*time.Second,
			)

			return result, err

		}
	*/

	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *s.file.Proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		methodGenCtx.generateClientMethodShim()
	}
}
func (s *methodGenContext) grpcClientMethodSignature() string {
	// 	CreateNATSClient(ctx context.Context, in *CreateNATSClientRequest, opts ...grpc.CallOption) (*CreateNATSClientResponse, error)

	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := ""
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+g.QualifiedGoIdent(contextPackage.Ident("Context")))

		reqArgs = append(reqArgs, "in *"+g.QualifiedGoIdent(method.Input.GoIdent))
		reqArgs = append(reqArgs, "opts ... "+g.QualifiedGoIdent(grpcPackage.Ident("CallOption")))
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"

	}

	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
func (s *methodGenContext) generateClientMethodShim() {
	/*
			func (s *serviceNATSClientServiceClient) CreateNATSClient(ctx context.Context, in *cloud_api_business_nats.CreateNATSClientRequest, opts ...grpc.CallOption) (*cloud_api_business_nats.CreateNATSClientResponse, error) {
				response := &cloud_api_business_nats.CreateNATSClientResponse{}

		result, err := HandleNATSRequest(
			ctx,
			s.nc,
			"go.mapped.dev.proto.cloud.api.business.nats.NATSClientService.CreateNATSClient",
			in,
			response,
			2*time.Second,
		)

		return result, err
			}
	*/
	method := s.ProtogenMethod

	g := s.g
	service := s.service
	internalClientName := fmt.Sprintf("%vNATSMicroClient", service.GoName)
	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", internalClientName, ") ", s.grpcClientMethodSignature(), "{")
	g.P("	response := &", method.Output.GoIdent.GoName, "{}")
	g.P("	result, err := ", serviceNatsMicroServicePackage.Ident("HandleNATSClientRequest"), "(")
	g.P("		ctx,")
	g.P("		s.nc,")
	g.P("		", fmtPackage.Ident("Sprintf"), "(\"%s.", method.GoName, "\",s.groupName),")
	g.P("		in,")
	g.P("		response,")
	g.P("		2*", g.QualifiedGoIdent(timePackage.Ident("Second")), ",")
	g.P("	)")
	g.P("   return result, err")
	g.P("}")
	g.P()

}

func (s *serviceGenContext) genService() {
	gen := s.gen
	file := s.file
	proto := file.Proto
	g := s.g
	service := s.service

	// IServiceEndpointRegistration
	interfaceGRPCServerName := fmt.Sprintf("%vServerNATSMicro", service.GoName)

	interfaceServerName := fmt.Sprintf("IFluffyCore%s", interfaceGRPCServerName)
	internalServerName := fmt.Sprintf("%vFluffyCoreServerNATSMicro", service.GoName)
	internalRegistrationServerName := fmt.Sprintf("%vFluffyCoreServerNATSMicroRegistration", service.GoName)

	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := newMethodGenContext(s.uniqueRunID, method, gen, file, g, service)
		s.MethodMapGenCtx[key] = methodGenCtx
	}

	g.P("// ", interfaceServerName, " defines the nats micro server interface")
	g.P("type ", interfaceServerName, " interface {")
	g.P("	", contractsNatsMicroServicePackage.Ident("INATSMicroService"))
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		// only do it if it is not streaming
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			g.P("  	", methodGenCtx.natsMethodSignature())
		}
	}
	g.P("}")
	g.P()

	g.P("type ", internalServerName, " struct {")
	//		natsMicroInterceptors contracts_nats_micro.INATSMicroInterceptors
	g.P("  	", "natsMicroInterceptors", " ", contractsNatsMicroServicePackage.Ident("INATSMicroInterceptors"))
	g.P("}")
	g.P()

	g.P("type ", internalRegistrationServerName, " struct {")
	g.P("  	", "service", " ", interfaceServerName)
	g.P("}")
	g.P()

	g.P("var stemService", internalServerName, " = (*", internalServerName, ") (nil)")
	g.P("var _ ", interfaceServerName, " = stemService", internalServerName)
	g.P()

	g.P("var stemService", internalRegistrationServerName, " = (*", internalRegistrationServerName, ") (nil)")
	g.P("var _ ", contractsNatsMicroServicePackage.Ident("INATSMicroServiceRegisration"), " = stemService", internalRegistrationServerName)
	g.P()

	g.P("func AddSingleton", internalServerName, "(cb ", diPackage.Ident("ContainerBuilder"), ") {")
	g.P("  	", diPackage.Ident("AddSingleton"), "[", contractsNatsMicroServicePackage.Ident("INATSMicroServiceRegisration"), "](cb, ", "stemService", internalRegistrationServerName, ".Ctor)")
	g.P("  	", diPackage.Ident("AddSingleton"), "[", interfaceServerName, "](cb, ", "stemService", internalServerName, ".Ctor)")

	g.P("}")
	g.P()

	g.P("func (s *", internalRegistrationServerName, ") Ctor(service ", interfaceServerName, ") (", contractsNatsMicroServicePackage.Ident("INATSMicroServiceRegisration"), ", error) {")
	g.P("  	return &", internalRegistrationServerName, "{")
	g.P("  		service: service,")
	g.P("  	}, nil")
	g.P("}")
	g.P()

	g.P("func (s *", internalRegistrationServerName, ") AddService(nc *", natsGoPackage.Ident("Conn"), ", option *", contractsNatsMicroServicePackage.Ident("NATSMicroServiceRegisrationOption"), ") (", natsGoMicroPackage.Ident("Service"), ", error) {")
	g.P("  	defaultConfig := &", natsGoMicroPackage.Ident("Config"), "{")
	g.P("  		Name:        \"", service.GoName, "\",")
	g.P("  		Version:     \"0.0.1\",")
	// we need to pull the Descriptin from the proto service comments.

	g.P("  		Description: \"The ", service.GoName, " nats micro service\",")
	g.P("  	}")
	g.P("  	for _, option := range option.NATSMicroConfigOptions {")
	g.P("  		option(defaultConfig)")
	g.P("  	}")
	g.P("  	svc, err := ", natsGoMicroPackage.Ident("AddService"), "(nc, *defaultConfig)")
	g.P("  	if err != nil {")
	g.P("  		return nil, err")
	g.P("  	}")
	atLeastOneMethod := false
	for _, method := range service.Methods {
		// only do it if it is not streaming
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			atLeastOneMethod = true
			break
		}
	}

	if atLeastOneMethod {
		g.P("  	pkgPath := ", reflectPackage.Ident("TypeOf"), "((*", interfaceServerName, ")(nil)).Elem().PkgPath()")
		g.P("  	fullPath := ", fmtPackage.Ident("Sprintf"), "(\"%s/%s\", pkgPath, \"", service.GoName, "\")")
		g.P("  	groupName := ", stringsPackage.Ident("ReplaceAll"), "(")
		g.P("  		fullPath,")
		g.P("  		\"/\",")
		g.P("  		\".\",")
		g.P("  	)")

		g.P("  	if ", fluffyCoreUtilsPackage.Ident("IsNotEmptyOrNil"), "(option.GroupName) {")
		g.P("  		groupName = option.GroupName")
		g.P("  	}")

		g.P("  	m := svc.AddGroup( groupName )")
	}
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		// only do it if it is not streaming
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			methodGenCtx.generateNATSMethodAddToServiceCall()
		}
	}
	g.P("  	return svc, nil")
	g.P("}")
	g.P()
	/*
			func (s *NATSMicroService) Interceptors() contracts_nats_micro.INATSMicroInterceptors {
			return s.natsMicroInterceptors
		}
	*/
	g.P("func (s *", internalServerName, ") Interceptors() ", contractsNatsMicroServicePackage.Ident("INATSMicroInterceptors"), " {")
	g.P("  	return s.natsMicroInterceptors")
	g.P("}")
	g.P()

	g.P("func (s *", internalServerName, ") Ctor(natsMicroInterceptors ", contractsNatsMicroServicePackage.Ident("INATSMicroInterceptors"), ") (", interfaceServerName, ", error) {")
	g.P("  	ss := &", internalServerName, "{")
	g.P("  		natsMicroInterceptors: natsMicroInterceptors,")
	g.P("  	}")
	g.P("  	return ss, nil")
	g.P("}")
	g.P()

	// Client method implementations.
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			methodGenCtx.generateNATSMicroMethodShim()
		}
	}
}

/*
m.AddEndpoint("CreateNATSClient",

	micro.HandlerFunc(s.service.CreateNATSClient),
	micro.WithEndpointMetadata(map[string]string{
		"description":     "CreateNATSClient",
		"format":          "application/json",
		"request_schema":  schemaFor(&cloud_api_business_nats.CreateNATSClientRequest{}),
		"response_schema": schemaFor(&cloud_api_business_nats.CreateNATSClientResponse{}),
	}))
*/
func (s *methodGenContext) generateNATSMethodAddToServiceCall() {

	method := s.ProtogenMethod
	g := s.g

	g.P("	m.AddEndpoint(\"", method.GoName, "\",")
	g.P("		", natsGoMicroPackage.Ident("HandlerFunc"), "(s.service.", method.GoName, "),")
	g.P("		", natsGoMicroPackage.Ident("WithEndpointMetadata"), "(map[string]string{")
	g.P("			\"description\":     \"", method.GoName, "\",")
	g.P("			\"format\":          \"application/json\",")
	g.P("			\"request_schema\": ", fluffyCoreUtilsPackage.Ident("SchemaFor"), "(&", method.Input.GoIdent.GoName, "{}),")
	g.P("			\"response_schema\": ", fluffyCoreUtilsPackage.Ident("SchemaFor"), "(&", method.Output.GoIdent.GoName, "{}),")
	g.P("		}))")
	g.P()

}

/*
// this gets directly registred as a handler in the nats micro service

	func (s *NATSMicroService) CreateNATSClient(req micro.Request) {
		handleRequest[
			cloud_api_business_nats.CreateNATSClientRequest,
			cloud_api_business_nats.CreateNATSClientResponse](
			s,
			req,
			func(r *cloud_api_business_nats.CreateNATSClientRequest) error {
				return protojson.Unmarshal(req.Data(), r)
			},
			func(ctx context.Context, request *cloud_api_business_nats.CreateNATSClientRequest) (*cloud_api_business_nats.CreateNATSClientResponse, error) {
				container := fluffycore_middleware_dicontext.GetRequestContainer(ctx)
				downstreamService := di.Get[cloud_api_business_nats.IFluffyCoreNATSClientServiceServer](container)
				return downstreamService.CreateNATSClient(ctx, request)
			},
		)

}
*/
func (s *methodGenContext) generateNATSMicroMethodShim() {

	method := s.ProtogenMethod
	g := s.g
	serverType := method.Parent.GoName

	interfaceServerName := fmt.Sprintf("IFluffyCore%vServer", method.Parent.GoName)
	internalServerName := fmt.Sprintf("%vFluffyCoreServerNATSMicro", serverType)

	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", internalServerName, ") ", s.natsMethodSignature(), "{")
	g.P("	", serviceNatsMicroServicePackage.Ident("HandleRequest"), "(")
	g.P("		s,")
	g.P("		req,")
	g.P("		func(r *", method.Input.GoIdent.GoName, ") error {")
	g.P("			return ", protojsonPackage.Ident("Unmarshal"), "(req.Data(), r)")
	g.P("		},")
	g.P("		func(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent.GoName, ") (*", method.Output.GoIdent.GoName, ", error) {")
	g.P("			container := ", diContextPackage.Ident("GetRequestContainer(ctx)"))
	g.P("			downstreamService := ", diPackage.Ident("Get"), "[", interfaceServerName, "](container)")
	g.P("			return downstreamService.", method.GoName, "(ctx,request)")
	g.P("		},")
	g.P("	)")
	g.P("}")
	g.P()
}

func (s *methodGenContext) natsMethodSignature() string {

	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string

	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "req "+g.QualifiedGoIdent(natsGoMicroPackage.Ident("Request")))
	}

	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") "
}

func (s *methodGenContext) unaryMethodSignature() string {
	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+g.QualifiedGoIdent(contextPackage.Ident("Context")))
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}

	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
